About sp1(Stack parser 1)
This project needs StoneValley and svregex.

A step-by-step guide to build your own expression parser

Howdy, folks! Let me introduce SP1 (stack parser 1) in this article by a math expression parsing program.

Firstly you need to know which algorithm this parser uses. Straightforwardly, it is Dijkstra's two stack algorithm. Yes, SP1 is based on Dijkstra's two stack algorithm also known as shunting yard algorithm but a little bit addition was coped with it, so it can handle expressions with operator precedence and associativity. Of course, it can cope with both suffix, infix and prefix operator. Moreover, it can handle functions with arbitrary parameters and common used identifiers in programming languages.

The Lexer

You need to know the lexer SP1 uses before you know how SP1 parses expressions. SP1 uses svregex as its lexical analyzer. Svregex allow users to input simple regular expressions and convert them to DFAs. These sorts of regular expressions are combined in a C structure called TRM. The first parameter in structure TRM (defined in sp1.h) is the regular expression that describes a terminator.

Let us continually look at the TRM structure. The TRM structure contains 9 members. We will see them one by one. re is the regular expression in TRM array or the string that a regular expression recognizes in a syntax tree node. type is the main type of this current TRM node. There are 8 types totally described in enumeration TRMTYPE. adtp is the additional type that this TRM node represents. adtp can indicate prefix operator and right to left associativity. adtp is a form of mask integer, it is described in ADDTYPE enumeration. il is the length that the lexer recognizes strings. For example "sin" is a function/operator of length 3. If a TRM can not identify length such as a number, il will be set to -1. level is the operator level of current TRM node. Notice that function level is defined with macro SP1C_FN_LEVEL at sp1.h. pc is parameter counter, for example, sin has 1 parameter and pow may have 2 parameters. calbk is a temporary member variable that points to an operator's call back function that is used to cope with operators. Lastly, x and y are cursor points of the lexer runs on your program string in memory.

Next let us recall the APIs that SP1 provided. 7 function were exported with SP1. We can use sp1LexCompile to build a lexer. The input parameter is the ARRAY_Z that contains TRMs. sp1LexDestroy is used to free lexer's spaces that is used to free a lex queue. sp1DestroySyntaxTree is used to free the entire syntax tree which generated by sp1ParseExpression. And sp1ParseExpression is used to produce a binary syntax tree. sp1PrintSyntaxTree is used to print the syntax tree on console. sp1RegisterID and sp1UnregisterID are used to register or unregister identifiers to parser.

We will dissect into function sp1ParseExpression and watch it's parameters and usage then. pq is the lex queue that is produced by sp1LexCompile. parrlex is the original TRM array both used by sp1LexCompile and sp1ParseExpression itself. ptafn is the function name trie. Use sp1RegisterID to register funtion names. Please note that when your are registering function names by using sp1RegisterID, pta is the function name trie, it is not the identifier name trie. name is a pointer to wide character string to a function name. And last but not least, a is the parameter counter of a function. If there needs to add 3 parameters, a should be 3. ptaid is the identifier trie that is used by function sp1ParseExpression. Use sp1RegisterID and sp1UnregisterID to manipulate them. In this case, when registering identifiers, parameter a of function sp1RegisterID is not used. wcstr is a pointer to a wide string of your own program to be parsed. err is a callback of error reporting function. 6 errors sp1ParseExpression produces. You may refer to the bottom of sp1.h. pln and  pcol points to line and column number.

To use this parser, firstly we need to create 2 tries, ptafn and ptaid, please refer to main.c line 336-337. Then we need to write TRMs, carefully assign levels to operators and types of terminators, and let sp1LexCompile to compile it and produce a lex queue. Next, we need to  use sp1RegisterID to register function names and parameter counters and identifiers. Please refer to main.c 340-342. The next step is to use sp1ParseExpression to generate a syntax tree. sp1ParseExpression returns the pointer to the root node of a syntax tree. If a program can not be parse, sp1ParseExpression will return NULL. Finally, we need to clean allocated memories. Sequentially, call sp1DestroySyntaxTree, sp1LexDestroy and treDeleteTrieA to achieve this step.

Now enjoy and proceed to process your syntax tree!

